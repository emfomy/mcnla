////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @file    include/mcnla/core/matrix/kit/array.hpp
/// @brief   The array.
///
/// @author  Mu Yang <<emfomy@gmail.com>>
///

#ifndef MCNLA_CORE_MATRIX_KIT_ARRAY_HPP_
#define MCNLA_CORE_MATRIX_KIT_ARRAY_HPP_

#include <mcnla/core/matrix/kit/array.hh>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  The MCNLA namespace.
//
namespace mcnla {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  The matrix namespace.
//
namespace matrix {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Default constructor.
///
template <typename _Val>
Array<_Val>::Array() noexcept
  : BaseType(kNullPtr),
    offset_(0) {}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Construct with given size information.
///
template <typename _Val>
Array<_Val>::Array(
    const index_t capacity,
    const index_t offset
) noexcept
  : BaseType(new std::valarray<_Val>(capacity)),
    offset_(offset) {}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Construct with given raw data.
///
template <typename _Val>
Array<_Val>::Array(
    const BaseType &ptr,
    const index_t offset
) noexcept
  : BaseType(ptr),
    offset_(offset) {
  mcnla_assert_gele(offset_, 0, size());
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Copy constructor.
///
/// @attention  It is shallow copy (creates an alias). For deep copy, uses `dst.#valarray() = src.#valarray()`.
///
template <typename _Val>
Array<_Val>::Array(
    const Array &other
) noexcept
  : BaseType(other),
    offset_(other.offset_) {}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Move constructor.
///
template <typename _Val>
Array<_Val>::Array(
    Array &&other
) noexcept
  : BaseType(std::move(other)),
    offset_(other.offset_) {
  static_cast<BaseType&>(other) = kNullPtr;
  other.offset_ = 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Copy assignment operator.
///
/// @attention  It is shallow copy (creates an alias). For deep copy, uses `dst.#valarray() = src.#valarray()`.
///
template <typename _Val>
Array<_Val>& Array<_Val>::operator=(
    const Array &other
) noexcept {
  BaseType::operator=(other);
  offset_ = other.offset_;
  return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Move assignment operator.
///
template <typename _Val>
Array<_Val>& Array<_Val>::operator=(
    Array &&other
) noexcept {
  BaseType::operator=(std::move(other)); static_cast<BaseType&>(other) = kNullPtr;
  offset_ = other.offset_; other.offset_ = 0;
  return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Right-shift the offset.
/// Add @a offset to @ref offset_.
///
template <typename _Val>
void Array<_Val>::operator>>=(
    const index_t offset
) noexcept {
  offset_ += offset;
  mcnla_assert_gele(offset_, 0, size());
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Left-shift the offset.
/// Subtract @ref offset_ by @a offset.
///
template <typename _Val>
void Array<_Val>::operator<<=(
    const index_t offset
) noexcept {
  offset_ -= offset;
  mcnla_assert_gele(offset_, 0, size());
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @copydoc  operator>>=
///
template <typename _Val>
Array<_Val> Array<_Val>::operator>>(
    const index_t offset
) noexcept {
  auto retval = *this;
  retval >>= offset;
  return retval;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @copydoc  operator>>=
///
template <typename _Val>
const Array<_Val> Array<_Val>::operator>>(
    const index_t offset
) const noexcept {
  auto retval = *this;
  retval >>= offset;
  return retval;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @copydoc  operator<<=
///
template <typename _Val>
Array<_Val> Array<_Val>::operator<<(
    const index_t offset
) noexcept {
  auto retval = *this;
  retval <<= offset;
  return retval;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @copydoc  operator<<=
///
template <typename _Val>
const Array<_Val> Array<_Val>::operator<<(
    const index_t offset
) const noexcept {
  auto retval = *this;
  retval <<= offset;
  return retval;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Determines if the memory size is zero.
///
template <typename _Val>
bool Array<_Val>::isEmpty() const noexcept {
  return (size() == 0);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Gets the memory size.
///
/// @note  #capacity + #offset = #size.
///
template <typename _Val>
index_t Array<_Val>::size() const noexcept {
  return this->valarray().size();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Gets the capacity.
///
/// @note  #capacity + #offset = #size.
///
template <typename _Val>
index_t Array<_Val>::capacity() const noexcept {
  return size() - offset();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Gets the offset.
///
/// @note  #capacity + #offset = #size.
///
template <typename _Val>
index_t Array<_Val>::offset() const noexcept {
  return offset_;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Gets the data pointer.
///
template <typename _Val>
_Val* Array<_Val>::operator*() noexcept {
  return &(this->valarray()[offset_]);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Gets the data pointer.
///
template <typename _Val>
const _Val* Array<_Val>::operator*() const noexcept {
  return &(this->valarray()[offset_]);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Gets the data of given index.
///
template <typename _Val>
_Val& Array<_Val>::operator[](
    const index_t idx
) noexcept {
  return this->valarray()[idx+offset_];
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Gets the data of given index.
///
template <typename _Val>
const _Val& Array<_Val>::operator[](
    const index_t idx
) const noexcept {
  return this->valarray()[idx+offset_];
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Gets the valarray.
///
template <typename _Val>
std::valarray<_Val>& Array<_Val>::valarray() noexcept {
  return *(this->get());
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief  Gets the valarray.
///
template <typename _Val>
const std::valarray<_Val>& Array<_Val>::valarray() const noexcept {
  return *(this->get());
}

}  // namespace matrix

}  // namespace mcnla

#endif  // MCNLA_CORE_MATRIX_KIT_ARRAY_HPP_

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @file    include/mcnla/core/matrix/kit/ptr.hh
/// @brief   The definition of fake pointer class.
///
/// @author  Mu Yang <<emfomy@gmail.com>>
///

#ifndef MCNLA_CORE_MATRIX_KIT_PTR_HH_
#define MCNLA_CORE_MATRIX_KIT_PTR_HH_

#include <mcnla/core/matrix/kit/def.hpp>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  The MCNLA namespace.
//
namespace mcnla {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  The matrix namespace.
//
namespace matrix {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @ingroup  matrix_kit_module
/// The fake pointer.
///
/// @tparam  _Val  The value type.
///
template <typename _Val>
class Ptr {

 protected:

  /// The object.
  _Val obj_;

 public:

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief  Construct with given object.
  ///
  Ptr(
    const _Val &obj
  ) noexcept
    : obj_(obj) {}


  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief  Indirection operator.
  ///
  inline _Val* operator->() noexcept {
    return &obj_;
  }


  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /// @copydoc  operator->()
  ///
  inline const _Val* operator->() const noexcept {
    return &obj_;
  }

};

}  // namespace matrix

}  // namespace mcnla

#undef MCNLA_ALIAS
#undef MCNLA_ALIAS0
#undef MCNLA_ALIAS1

#endif  // MCNLA_CORE_MATRIX_KIT_PTR_HH_

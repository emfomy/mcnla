namespace mcnla {

namespace isvd {

/**
  @page tutorial_isvd iSVD %Driver

  <h3>iSVD %Driver</h3>

  The @ref Driver "iSVD Driver" solves a approximate low-rank singular value decomposition of matrix `a`.

  <h3>Example</h3>

  The following is an example of using @ref Driver "iSVD Driver":

  <h4>Initialize Environment</h4>

  The MPI environment and random seed should be set up before calling @ref Driver "iSVD Driver".

  @code{.cpp}
  // Initialize MPI
  MPI_Init(&argc, &argv);
  mcnla::mpi_int_t mpi_root = 0;
  mcnla::mpi_int_t mpi_rank = mcnla::mpi::commRank(MPI_COMM_WORLD);

  // Initialize random seed
  srand(time(NULL));
  mcnla::index_t seed = rand();
  @endcode

  <h4>Load Data</h4>

  One may use @ref mcnla::io::loadMatrixMarket to load a matrix from a Matrix Market format file. Note the matrix should be boardcasted to all MPI nodes.

  @code{.cpp}
  // Load matrix
  mcnla::DenseMatrix<double> matrix_a;
  mcnla::index_t asize0, asize1;
  auto sizes = matrix_a.sizes();
  if ( mcnla::mpi::isCommRoot(MPI_COMM_WORLD, mpi_root) ) {
    mcnla::io::loadMatrixMarket(matrix_a, "a.mtx");
    sizes = matrix_a.sizes();
  }
  MPI_Bcast(&sizes, 2, mcnla::traits::MpiValTraits<mcnla::index_t>::datatype, mpi_root, MPI_COMM_WORLD);
  if ( !mcnla::mpi::isCommRoot(MPI_COMM_WORLD, mpi_root) ) {
    matrix_a.reconstruct(sizes);
  }
  mcnla::mpi::bcast(matrix_a, mpi_root, MPI_COMM_WORLD);
  @endcode

  <h4>Initialize %Driver</h4>

  The @ref Driver "iSVD Driver" should be @ref Driver::initialize "initialized" be before @ref Driver::compute "compute". In initialization, the driver boardcasts the parameters and allocates the memories.

  Note that most of the `set?()` methods only affect on the root node. @ref Driver::setSeeds should called by all the nodes, although only the value on root node is used. @ref Driver::initialize also required to be called by all the nodes.

  @code{.cpp}
  // Set parameters
  mcnla::index_t Nj    = 4;
  mcnla::index_t k     = 16;
  mcnla::index_t p     = 12;
  double         tol   = 1e-4;
  mcnla::index_t maxit = 256;

  // Initialize %driver
  mcnla::isvd::Driver<double,
                      mcnla::isvd::GaussianProjectionSketcherTag<0>,
                      mcnla::isvd::SvdOrthogonalizerTag,
                      mcnla::isvd::KolmogorovNagumoIntegratorTag,
                      mcnla::isvd::SvdFormerTag> driver(MPI_COMM_WORLD);
  driver.setSize(matrix_a).setRank(k).setOverRank(p).setNumSketchEach(Nj).setSeeds(seed);
  driver.setTolerance(tol).setMaxIteration(maxit);
  driver.initialize();
  @endcode

  <h4>Run %Driver</h4>

  The @ref Driver "iSVD Driver" compute the approximate low-rank singular value decomposition while calling @ref Driver::compute.

  @code{.cpp}
  // Run iSVD
  driver.compute(matrix_a);
  @endcode

  <h4>Get Executing Time</h4>

  The @ref Driver "iSVD Driver" also records the executing time of each step.

  @code{.cpp}
  // Display executing time
  if ( mcnla::mpi::isCommRoot(MPI_COMM_WORLD, mpi_root) ) {
    auto time_s = driver.sketcherTime();
    auto time_i = driver.integratorTime();
    auto time_o = driver.orthogonalizerTime();
    auto time_f = driver.formerTime();
    auto time = time_s + time_o + time_i + time_f;

    std::cout << "Average total computing time: " << time   << " seconds." << std::endl;
    std::cout << "Average sketching time:       " << time_s << " seconds." << std::endl;
    std::cout << "Average orthogonalizing time: " << time_o << " seconds." << std::endl;
    std::cout << "Average integrating time:     " << time_i << " seconds." << std::endl;
    std::cout << "Average forming time:         " << time_f << " seconds." << std::endl;
  }
  @endcode

  <h4>Save Data</h4>

  One may use @ref mcnla::io::saveMatrixMarket to save the results into Matrix Market format files.

  @code{.cpp}
  // Save matrix
  if ( mcnla::mpi::isCommRoot(MPI_COMM_WORLD, mpi_root) ) {
    mcnla::io::saveMatrixMarket(driver.singularValues(),       "s.mtx");
    mcnla::io::saveMatrixMarket(driver.leftSingularVectors(),  "u.mtx");
    mcnla::io::saveMatrixMarket(driver.rightSingularVectors(), "vt.mtx");
  }
  @endcode

  <h4>Finalize</h4>

  Remember to finalize the MPI.

  @code{.cpp}
  // Finalize MPI
  MPI_Finalize();

  @endcode

  @see @ref isvd_module

*/

}  // namespace isvd

}  // namespace mcnla
